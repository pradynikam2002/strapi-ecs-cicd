const TABLE = 'unknown_flags';
const MAX_INSERT_BATCH_SIZE = 100;
export class UnknownFlagsStore {
    constructor(db, getLogger) {
        this.db = db;
        this.logger = getLogger('unknown-flags-store.ts');
    }
    async insert(flags) {
        if (!flags.length)
            return;
        const rows = flags.map(({ name, appName, seenAt, environment }) => ({
            name,
            app_name: appName,
            seen_at: seenAt,
            environment,
        }));
        for (let i = 0; i < rows.length; i += MAX_INSERT_BATCH_SIZE) {
            const chunk = rows.slice(i, i + MAX_INSERT_BATCH_SIZE);
            try {
                await this.db(TABLE)
                    .insert(chunk)
                    .onConflict(['name', 'app_name', 'environment'])
                    .merge(['seen_at']);
            }
            catch (error) {
                this.logger.debug(`unknown_flags: batch ${i / MAX_INSERT_BATCH_SIZE + 1} failed and was skipped.`, error);
            }
        }
    }
    async getAll({ limit, orderBy } = {}) {
        let query = this.db(TABLE).select('name', 'app_name', 'seen_at', 'environment');
        if (orderBy) {
            query = query.orderBy(orderBy);
        }
        if (limit) {
            query = query.limit(limit);
        }
        const rows = await query;
        return rows.map((row) => ({
            name: row.name,
            appName: row.app_name,
            seenAt: new Date(row.seen_at),
            environment: row.environment,
        }));
    }
    async clear(hoursAgo) {
        return this.db(TABLE)
            .whereRaw(`seen_at <= NOW() - INTERVAL '${hoursAgo} hours'`)
            .del();
    }
    async deleteAll() {
        await this.db(TABLE).delete();
    }
    async count() {
        const row = await this.db(TABLE).count('* as count').first();
        return Number(row?.count ?? 0);
    }
}
//# sourceMappingURL=unknown-flags-store.js.map