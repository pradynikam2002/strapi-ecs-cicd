import { differenceInCalendarMonths, endOfDay, format, isSameMonth, parse, startOfDay, } from 'date-fns';
export class FakeTrafficDataUsageStore {
    constructor() {
        this.trafficData = [];
    }
    get(key) {
        throw new Error('Method not implemented.');
    }
    getAll(query) {
        throw new Error('Method not implemented.');
    }
    exists(key) {
        throw new Error('Method not implemented.');
    }
    delete(key) {
        throw new Error('Method not implemented.');
    }
    deleteAll() {
        throw new Error('Method not implemented.');
    }
    destroy() {
        throw new Error('Method not implemented.');
    }
    async upsert(trafficDataUsage) {
        const index = this.trafficData.findIndex((data) => data.day.getTime() === trafficDataUsage.day.getTime() &&
            data.trafficGroup === trafficDataUsage.trafficGroup &&
            data.statusCodeSeries === trafficDataUsage.statusCodeSeries);
        if (index >= 0) {
            this.trafficData[index].count += trafficDataUsage.count;
        }
        else {
            this.trafficData.push(trafficDataUsage);
        }
    }
    async getTrafficDataUsageForPeriod(period) {
        const periodDate = parse(period, 'yyyy-MM', new Date());
        return this.trafficData.filter((data) => isSameMonth(data.day, periodDate));
    }
    async getTrafficDataForMonthRange(monthsBack) {
        const now = new Date();
        const data = this.trafficData
            .filter((entry) => differenceInCalendarMonths(now, entry.day) <=
            monthsBack)
            .reduce((acc, entry) => {
            const month = format(entry.day, 'yyyy-MM');
            const key = `${month}-${entry.trafficGroup}-${entry.statusCodeSeries}`;
            if (acc[key]) {
                acc[key].count += entry.count;
            }
            else {
                acc[key] = {
                    month,
                    trafficGroup: entry.trafficGroup,
                    statusCodeSeries: entry.statusCodeSeries,
                    count: entry.count,
                };
            }
            return acc;
        }, {});
        return Object.values(data);
    }
    async getDailyTrafficDataUsageForPeriod(from, to) {
        return this.trafficData.filter((data) => data.day >= startOfDay(from) && data.day <= endOfDay(to));
    }
    async getMonthlyTrafficDataUsageForPeriod(from, to) {
        const data = this.trafficData
            .filter((data) => data.day >= startOfDay(from) &&
            data.day <= endOfDay(to))
            .reduce((acc, entry) => {
            const month = format(entry.day, 'yyyy-MM');
            const key = `${month}-${entry.trafficGroup}-${entry.statusCodeSeries}`;
            if (acc[key]) {
                acc[key].count += entry.count;
            }
            else {
                acc[key] = {
                    month,
                    trafficGroup: entry.trafficGroup,
                    statusCodeSeries: entry.statusCodeSeries,
                    count: entry.count,
                };
            }
            return acc;
        }, {});
        return Object.values(data);
    }
}
//# sourceMappingURL=fake-traffic-data-usage-store.js.map