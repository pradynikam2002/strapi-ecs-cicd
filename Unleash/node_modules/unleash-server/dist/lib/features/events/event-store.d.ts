import { type IBaseEvent, type IEvent } from '../../events/index.js';
import type { LogProvider } from '../../logger.js';
import type { IEventSearchParams, IEventStore } from '../../types/stores/event-store.js';
import type { Db } from '../../db/db.js';
import type { Knex } from 'knex';
import type EventEmitter from 'node:events';
import type { ProjectActivitySchema } from '../../openapi/index.js';
import type { IQueryParam } from '../feature-toggle/types/feature-toggle-strategies-store-type.js';
import type { ITag } from '../../tags/index.js';
export type IQueryOperations = IWhereOperation | IBeforeDateOperation | IBetweenDatesOperation | IForFeaturesOperation;
interface IWhereOperation {
    op: 'where';
    parameters: {
        [key: string]: string;
    };
}
interface IBeforeDateOperation {
    op: 'beforeDate';
    parameters: {
        dateAccessor: string;
        date: string;
    };
}
interface IBetweenDatesOperation {
    op: 'betweenDate';
    parameters: {
        dateAccessor: string;
        range: string[];
    };
}
interface IForFeaturesOperation {
    op: 'forFeatures';
    parameters: IForFeaturesParams;
}
interface IForFeaturesParams {
    type: string;
    projectId: string;
    environments: string[];
    features: string[];
}
export interface IEventTable {
    id: number;
    type: string;
    created_by: string;
    created_at: Date;
    created_by_user_id: number;
    data?: any;
    pre_data?: any;
    feature_name?: string;
    project?: string;
    environment?: string;
    tags: ITag[];
    ip?: string;
    group_type: string | null;
    group_id: string | null;
}
export declare class EventStore implements IEventStore {
    private db;
    private eventEmitter;
    private logger;
    private metricTimer;
    constructor(db: Db, getLogger: LogProvider);
    store(event: IBaseEvent): Promise<void>;
    count(): Promise<number>;
    searchEventsCount(queryParams: IQueryParam[], query?: IEventSearchParams['query']): Promise<number>;
    batchStore(events: IBaseEvent[]): Promise<void>;
    getMaxRevisionId(largerThan?: number): Promise<number>;
    getRevisionRange(start: number, end: number): Promise<IEvent[]>;
    delete(key: number): Promise<void>;
    deleteAll(): Promise<void>;
    destroy(): void;
    exists(key: number): Promise<boolean>;
    query(operations: IQueryOperations[]): Promise<IEvent[]>;
    queryCount(operations: IQueryOperations[]): Promise<number>;
    where(query: Knex.QueryBuilder, parameters: {
        [key: string]: string;
    }): Knex.QueryBuilder;
    beforeDate(query: Knex.QueryBuilder, parameters: {
        dateAccessor: string;
        date: string;
    }): Knex.QueryBuilder;
    betweenDate(query: Knex.QueryBuilder, parameters: {
        dateAccessor: string;
        range: string[];
    }): Knex.QueryBuilder;
    select(): Knex.QueryBuilder;
    forFeatures(query: Knex.QueryBuilder, parameters: IForFeaturesParams): Knex.QueryBuilder;
    get(key: number): Promise<IEvent>;
    getAll(query?: Object): Promise<IEvent[]>;
    getEvents(query?: Object): Promise<IEvent[]>;
    searchEvents(params: IEventSearchParams, queryParams: IQueryParam[], options?: {
        withIp?: boolean;
    }): Promise<IEvent[]>;
    private buildSearchQuery;
    getEventCreators(): Promise<Array<{
        id: number;
        name: string;
    }>>;
    getProjectRecentEventActivity(project: string): Promise<ProjectActivitySchema>;
    rowToEvent(row: IEventTable): IEvent;
    eventToDbRow(e: IBaseEvent): Omit<IEventTable, 'id' | 'created_at'>;
    setMaxListeners(number: number): EventEmitter;
    on(eventName: string | symbol, listener: (...args: any[]) => void): EventEmitter;
    emit(eventName: string | symbol, ...args: any[]): boolean;
    off(eventName: string | symbol, listener: (...args: any[]) => void): EventEmitter;
    setUnannouncedToAnnounced(): Promise<IEvent[]>;
    publishUnannouncedEvents(): Promise<void>;
    setCreatedByUserId(batchSize: number): Promise<number | undefined>;
}
export default EventStore;
//# sourceMappingURL=event-store.d.ts.map