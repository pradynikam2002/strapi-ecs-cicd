import crypto from 'crypto';
import bcrypt from 'bcryptjs';
import { URL } from 'url';
import UsedTokenError from '../error/used-token-error.js';
import InvalidTokenError from '../error/invalid-token-error.js';
import { hoursToMilliseconds } from 'date-fns';
export default class ResetTokenService {
    constructor({ resetTokenStore }, { getLogger, server }) {
        this.expireExistingTokensForUser = async (userId) => {
            return this.store.expireExistingTokensForUser(userId);
        };
        this.store = resetTokenStore;
        this.logger = getLogger('/services/reset-token-service.ts');
        this.unleashBase = server.unleashUrl;
    }
    async useAccessToken(token) {
        try {
            await this.isValid(token.token);
            await this.store.useToken(token);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    async getActiveInvitations() {
        try {
            const tokens = await this.store.getActiveTokens();
            const links = tokens.reduce((acc, token) => {
                const inviteLink = this.getExistingInvitationUrl(token).toString();
                acc[token.userId] = inviteLink;
                return acc;
            }, {});
            return links;
        }
        catch (e) {
            return {};
        }
    }
    async isValid(token) {
        let t;
        try {
            t = await this.store.getActive(token);
            if (!t.usedAt) {
                return t;
            }
        }
        catch (e) {
            throw new InvalidTokenError();
        }
        throw new UsedTokenError(t.usedAt);
    }
    getExistingInvitationUrl(token) {
        return new URL(`${this.unleashBase}/new-user?token=${token.token}`);
    }
    async createResetUrl(forUser, creator, path) {
        const token = await this.createToken(forUser, creator);
        return Promise.resolve(new URL(`${this.unleashBase}${path}?token=${token.token}`));
    }
    async createResetPasswordUrl(forUser, creator) {
        const path = '/reset-password';
        return this.createResetUrl(forUser, creator, path);
    }
    async createNewUserUrl(forUser, creator) {
        const path = '/new-user';
        return this.createResetUrl(forUser, creator, path);
    }
    async createToken(tokenUser, creator, expiryDelta = hoursToMilliseconds(24)) {
        const token = await this.generateToken();
        const expiry = new Date(Date.now() + expiryDelta);
        await this.expireExistingTokensForUser(tokenUser);
        return this.store.insert({
            reset_token: token,
            user_id: tokenUser,
            expires_at: expiry,
            created_by: creator,
        });
    }
    generateToken() {
        return bcrypt.hash(crypto.randomBytes(32).toString(), 10);
    }
}
//# sourceMappingURL=reset-token-service.js.map