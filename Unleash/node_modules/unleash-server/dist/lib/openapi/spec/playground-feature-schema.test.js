import fc from 'fast-check';
import { strategyConstraint, urlFriendlyString, variants, } from '../../../test/arbitraries.test.js';
import { validateSchema } from '../validate.js';
import { playgroundFeatureSchema, } from './playground-feature-schema.js';
import { playgroundStrategyEvaluation, } from './playground-strategy-schema.js';
const playgroundStrategyConstraint = () => fc
    .tuple(fc.boolean(), strategyConstraint())
    .map(([result, constraint]) => ({
    ...constraint,
    result,
}));
const playgroundStrategyConstraints = () => fc.array(playgroundStrategyConstraint());
const playgroundSegment = () => fc.record({
    name: fc.string({ minLength: 1 }),
    id: fc.nat(),
    result: fc.boolean(),
    constraints: playgroundStrategyConstraints(),
});
const playgroundStrategy = (name, parameters) => fc.record({
    id: fc.uuid(),
    name: fc.constant(name),
    result: fc.oneof(fc.record({
        evaluationStatus: fc.constant(playgroundStrategyEvaluation.evaluationComplete),
        enabled: fc.boolean(),
    }), fc.record({
        evaluationStatus: fc.constant(playgroundStrategyEvaluation.evaluationIncomplete),
        enabled: fc.constantFrom(playgroundStrategyEvaluation.unknownResult, false),
    })),
    parameters,
    constraints: playgroundStrategyConstraints(),
    segments: fc.array(playgroundSegment()),
    disabled: fc.boolean(),
    links: fc.constant({
        edit: '/projects/some-project/features/some-feature/strategies/edit?environmentId=some-env&strategyId=some-strat',
    }),
});
const playgroundStrategies = () => fc.array(fc.oneof(playgroundStrategy('default', fc.constant({})), playgroundStrategy('flexibleRollout', fc.record({
    groupId: fc.lorem({ maxCount: 1 }),
    rollout: fc.nat({ max: 100 }).map(String),
    stickiness: fc.constantFrom('default', 'userId', 'sessionId'),
})), playgroundStrategy('applicationHostname', fc.record({
    hostNames: fc
        .uniqueArray(fc.domain())
        .map((domains) => domains.join(',')),
})), playgroundStrategy('remoteAddress', fc.record({
    IPs: fc.uniqueArray(fc.ipV4()).map((ips) => ips.join(',')),
}))));
export const generate = () => fc
    .tuple(variants(), fc.nat(), fc.record({
    isEnabledInCurrentEnvironment: fc.boolean(),
    projectId: urlFriendlyString(),
    name: urlFriendlyString(),
    strategies: playgroundStrategies(),
}))
    .map(([generatedVariants, activeVariantIndex, feature]) => {
    const strategyResult = () => {
        const { strategies } = feature;
        if (strategies.some((strategy) => strategy.result.enabled === true)) {
            return true;
        }
        if (strategies.some((strategy) => strategy.result.enabled === 'unknown')) {
            return 'unknown';
        }
        return false;
    };
    const isEnabled = feature.isEnabledInCurrentEnvironment &&
        strategyResult() === true;
    // the active variant is the disabled variant if the feature is
    // disabled or has no variants.
    let activeVariant = { name: 'disabled', enabled: false };
    if (generatedVariants.length && isEnabled) {
        const targetVariant = generatedVariants[activeVariantIndex % generatedVariants.length];
        const targetPayload = targetVariant.payload
            ? targetVariant.payload
            : undefined;
        activeVariant = {
            enabled: true,
            name: targetVariant.name,
            payload: targetPayload,
        };
    }
    return {
        ...feature,
        isEnabled,
        strategies: {
            result: strategyResult(),
            data: feature.strategies,
        },
        variants: generatedVariants,
        variant: activeVariant,
    };
});
test('playgroundFeatureSchema', () => fc.assert(fc.property(generate(), fc.context(), (data, ctx) => {
    const results = validateSchema(playgroundFeatureSchema.$id, data);
    ctx.log(JSON.stringify(results));
    return results === undefined;
})));
//# sourceMappingURL=playground-feature-schema.test.js.map