import { Context } from '../context';
type MetricType = 'counter' | 'gauge';
export interface MetricSample {
    labels: MetricLabels;
    value: number;
}
export interface CollectedMetric {
    name: string;
    help: string;
    type: MetricType;
    samples: MetricSample[];
}
export type MetricLabels = Record<string, string>;
export interface Counter {
    inc(value?: number, labels?: MetricLabels): void;
}
export interface Gauge {
    inc(value?: number, labels?: MetricLabels): void;
    dec(value?: number, labels?: MetricLabels): void;
    set(value: number, labels?: MetricLabels): void;
}
export interface ImpactMetricsDataSource {
    collect(): CollectedMetric[];
    restore(metrics: CollectedMetric[]): void;
}
export interface ImpactMetricRegistry {
    getCounter(counterName: string): Counter | undefined;
    getGauge(gaugeName: string): Gauge | undefined;
    counter(opts: MetricOptions): Counter;
    gauge(opts: MetricOptions): Gauge;
}
export declare class InMemoryMetricRegistry implements ImpactMetricsDataSource, ImpactMetricRegistry {
    private counters;
    private gauges;
    getCounter(counterName: string): Counter | undefined;
    getGauge(gaugeName: string): Gauge | undefined;
    counter(opts: MetricOptions): Counter;
    gauge(opts: MetricOptions): Gauge;
    collect(): CollectedMetric[];
    restore(metrics: CollectedMetric[]): void;
}
export interface MetricOptions {
    name: string;
    help: string;
    labelNames?: string[];
}
export interface MetricFlagContext {
    flagNames: string[];
    context: Context;
}
export {};
//# sourceMappingURL=metric-types.d.ts.map